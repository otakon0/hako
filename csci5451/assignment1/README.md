# 目的
- k-means法をpthreadのAPIとOpenMPをそれぞれ用いて計算し、かかった時間を計算する。

## 環境：
- sshで専用のpcにログイン。
- ミネソタ大学のスパコン？

## 実験方法
- 500次元の509256個のデータを読み込み、(i) 256, (ii) 512, (iii) 1024 個クラスターを作った場合に対して測定した。(インプットファイルは 1.3G)
- また、それぞれスレッドの数を1,2,4,8,16の場合で行い、さらにpthreadバージョンとOpenMPバージョンがあったため、計3*5*2 = 30回プログラムを回したことになる。
- makeを実行後、'./km_pthreads /export/scratch/CSCI-5451/assignment-1/large_cpd.txt 512 2' でプログラムを走らせる。
- 課題提出期限直前だったため、バックグラウンドで実行し、計測時間は標準出力からベルファイルにリダイレクトさせた。
- topコマンドでメモリやCPU使用率を確認できる。また、他の人も同じPCを利用するので空いているPCを選んだ。

## 実験結果
実験結果は以下のようであった。(単位は秒）

- pthreads API

|    |   1|   2|   4|   8|  16|
|---:|---:|---:|---:|---:|---:|
| 256| 6890.5272| 3443.6058| 1726.5271|  879.7740|  671.2126|
| 512|17035.1715|10641.8781| 6709.7006| 3550.5673| 2654.2866|
|1024|3590.7771||15135.1526| 8129.2457| 6592.0930| 3789.1340|

- OpenMP

|    |   1|   2|   4|   8|  16|
|---:|---:|---:|---:|---:|---:|
| 256|13417.2606| 8103.2399| 3407.8472| 1577.8350| 1034.8410|
| 512|20996.0479|12183.9325| 4964.6710| 3209.6640| 2334.2126|
|1024|34856.3779|20177.4826|12240.8179| 8139.3634| 5842.0000|


## 考察
- OpenMPの方が遅い。おそらく、クラスター計算ごとにグローバルな（スレッド固有でない）変数を更新しているから。その際のcriticalディレクティブのせいか？
- OpenMPの方がコーディングしやすい。
- pthreadではほとんどの変数をローカルにしてから計算したが、その方が早い。
- OpenMPでのforループがすごくやりづらい。OpenMPは複雑なアルゴリズムには向かず、pthreadの低レベルAPIの方が難しいアルゴリズムに向いていると言われるが、k-means法は複雑な部類に入る説。


## 疑問点
- （人道的な観点からやらなかったけれど）他人のプロセスをkillできるのか？
- ディスカッションフォーラムに、クラスタ512個16スレッドを1300程度できたという意見があったので自分のプログラムはかなり遅い。どうやって改善できるか？

## 感想
- 課題を舐めきってたら痛い目に会いました。物理的に課題提出できないかと思いました。次からは１週間前には着手し始めます。
- １０時間sshが途切れないかどうかをチェックしてつきっきりでmacの看病をしていました。
