# 目的
- k-means法をpthreadのAPIとOpenMPをそれぞれ用いて計算し、かかった時間を計算する。

# 注意点：そもそもアルゴリズムの結果が正しいかどうか検証している時間と環境がなかったので間違っている可能性あり...

## 環境：
- sshで専用のpcにログイン。
- ミネソタ大学のスパコン？

## 実験方法
- 500次元の509256個のデータを読み込み、(i) 256, (ii) 512, (iii) 1024 個クラスターを作った場合に対して測定した。(インプットファイルのサイズは 1.3Gもあった。)
- また、それぞれスレッドの数を1,2,4,8,16の場合で行い、さらにpthreadバージョンとOpenMPバージョンがあったため、計3*5*2 = 30パターンでプログラムを回したことになる。
- makeを実行後、'./km_pthreads /export/scratch/CSCI-5451/assignment-1/large_cpd.txt 512 2' でプログラムを走らせる。
- 課題提出期限直前だったため、バックグラウンドで実行し、計測時間は標準出力から別ファイルにリダイレクトさせた。
- topコマンドでメモリやCPU使用率を確認できる。また、他の人も同じPCを利用するので空いているPCを選んだ。

## 実験結果
実験結果は以下のようであった。(単位は秒）

- pthreads API

|    |   1|   2|   4|   8|  16|
|---:|---:|---:|---:|---:|---:|
| 256| 6890.5272| 3443.6058| 1726.5271|  879.7740|  671.2126|
| 512|17035.1715|10641.8781| 6709.7006| 3550.5673| 2654.2866|
|1024|35906.7771|15135.1526| 8129.2457| 6592.0930| 3789.1340|

- OpenMP

|    |   1|   2|   4|   8|  16|
|---:|---:|---:|---:|---:|---:|
| 256|13417.2606| 8103.2399| 3407.8472| 1577.8350| 1034.8410|
| 512|20996.0479|12183.9325| 4964.6710| 3209.6640| 2334.2126|
|1024|34856.3779|20177.4826|12240.8179| 8139.3634| 5842.0000|


## 考察
- OpenMPの方が遅い。おそらく、クラスター計算ごとにグローバルな（スレッド固有でない）変数を更新しているから。その際のcriticalディレクティブのせいか？
- OpenMPの方がコーディングしやすい。
- pthreadではほとんどの変数をローカルにしてから計算したが、その方が早い。
- OpenMPでのforループがすごくやりづらい。OpenMPは複雑なアルゴリズムには向かず、pthreadの低レベルAPIの方が難しいアルゴリズムに向いていると言われるが、k-means法は複雑な部類に入る説。
- fullグレードのためには、シングルスレッドの最低１３倍の早く１６スレッドは処理しないといけない。（未達成）
- 他の人が別のプログラムを走らせたために、自分のプログラムにCPU時間をスライスしてもらえないので遅くなった可能性あり。

## 疑問点
- （人道的な観点からやらなかったけれど）他人のプロセスをkillできるのか？
- ディスカッションフォーラムに、クラスタ512個16スレッドを1300程度できたという意見があったので自分のプログラムはかなり遅い。どうやって改善できるか？
- niceコマンドで優先度をあげると実行速度早くなるのか？
- topコマンドでプロセスの状態を確認すると、pthreadバージョンのときのみ、クラスタ多いかつスレッド数が少ないとステータスがSl状態。Sはスレッド割り込み状態でSleepなので動いていないかのように思われるが、実は動いているっぽい。一方、OpenMPに関してはどの条件でもステータスはR。謎。


## 感想
- 課題を舐めきってたら痛い目に会いました。物理的に課題提出できないかと思いました。次からは１週間前には着手し始めます。
- １０時間sshが途切れないかどうかをチェックしてつきっきりでmacの看病をしていました。
