# 目的
- k-means法をpthreadのAPIとOpenMPをそれぞれ用いて計算し、かかった時間を計算する。それらのAPIに慣れること。s

## 注意点：そもそもアルゴリズムの結果が正しいかどうか検証している時間と環境がなかったので間違っている可能性あり...

## 環境：
- ミネソタ大学のスパコン？

## 実験方法
- 500次元の509256個のデータを読み込み、(i) 256, (ii) 512, (iii) 1024 個クラスターを作った場合に対して測定した。(インプットファイルのサイズは 1.3G)
- また、それぞれスレッドの数を1,2,4,8,16の場合で行い、さらにpthreadバージョンとOpenMPバージョンで実行した。計3×5×2 = 30パターンでプログラムを回したことになる。


## 実験結果
実験結果は以下のようであった。(単位は秒）

- pthreads API

|    |   1|   2|   4|   8|  16|
|---:|---:|---:|---:|---:|---:|
| 256| 6890.5272| 3443.6058| 1726.5271|  879.7740|  671.2126|
| 512|17035.1715|10641.8781| 6709.7006| 3550.5673| 2654.2866|
|1024|35906.7771|15135.1526| 8129.2457| 6592.0930| 3789.1340|

- OpenMP

|    |   1|   2|   4|   8|  16|
|---:|---:|---:|---:|---:|---:|
| 256|13417.2606| 8103.2399| 3407.8472| 1577.8350| 1034.8410|
| 512|20996.0479|12183.9325| 4964.6710| 3209.6640| 2334.2126|
|1024|34856.3779|20177.4826|12240.8179| 8139.3634| 5842.0000|


## 考察
- 結果より、OpenMPの方が遅い。おそらく、クラスター計算ごとにグローバルな（スレッド固有でない）変数を更新しているからだと考えられる。その際のcriticalディレクティブのせいか？
- pthreadではほとんどの変数をローカルにしてから計算したが、その方が早い。
- OpenMPは複雑なアルゴリズムには向かず、pthreadの低レベルAPIの方が難しいアルゴリズムに向いていると言われるが、OpneMPではk-means法は実装するのが大変だったため、複雑な部類に入るのではないか（あるいは向いてない）。
- 他の人が別のプログラムを走らせたために、自分のプログラムにCPU時間をスライスしてもらえないので遅くなった可能性あるのか。

## 疑問点
- （人道的な観点からやらなかったけれど）他人のプロセスをkillできるのか？
- ディスカッションフォーラムに、クラスタ512個16スレッドを1300程度できたという意見があったので自分のプログラムはかなり遅い。どうやって改善できるか？また、16スレッドのとき、シングルスレッドの13倍の速度が出るらしいが達成できなかった。
- niceコマンドで優先度をあげると実行速度早くなるのか？
- topコマンドでプロセスの状態を確認すると、pthreadバージョンのときのみ、かつクラスタ多いかつスレッド数が少ないとステータスがSl状態。Sはスレッド割り込み状態でSleepしているので動いていないかのように思われるが、実は動いているっぽい。一方、OpenMPに関してはどの条件でもステータスはR。謎。


## 感想
- 課題を舐めきってたら痛い目に会いました。物理的に課題提出できないかと思いました。次からは１週間前には着手し始めます。
- １０時間sshが途切れないかどうかをチェックしてつきっきりでmacの看病をしていました。（screenコマンドが使えた可能性あり）
